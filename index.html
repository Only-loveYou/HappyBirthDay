<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wedding</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #startBtn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 20px;
            background: transparent;
            color: #ff69b4;
            border: 2px solid #ff69b4;
            cursor: pointer;
            z-index: 100;
            border-radius: 50px;
            box-shadow: 0 0 15px #ff69b4;
            transition: all 0.3s;
            font-weight: bold;
            animation: pulse 2s infinite;
            white-space: nowrap;
            /* T·ªëi ∆∞u hi·ªÉn th·ªã n√∫t tr√™n mobile */
            -webkit-tap-highlight-color: transparent;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 105, 180, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(255, 105, 180, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 105, 180, 0); }
        }
    </style>
</head>

<body>

    <audio id="bgMusic" loop>
        <source src="HPBDD.MP3" type="audio/mpeg">
    </audio>

    <button id="startBtn">üë∞ T ‚ô•Ô∏è H ü§µ</button>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // alpha: false gi√∫p tƒÉng t·ªëc render
        const btn = document.getElementById('startBtn');
        const audio = document.getElementById('bgMusic');

        // üü¢ C·∫§U H√åNH T·ªà L·ªÜ M√ÄN H√åNH (QUAN TR·ªåNG NH·∫§T)
        // L·∫•y t·ªâ l·ªá pixel th·ª±c c·ªßa thi·∫øt b·ªã (iPhone th∆∞·ªùng l√† 3, Android th∆∞·ªùng l√† 2-3)
        let DPR = window.devicePixelRatio || 1; 

        // C√°c bi·∫øn to√†n c·ª•c
        let canvasWidth, canvasHeight;
        let particles = [];
        let drops = [];
        let fontSize;
        
        // C·∫•u h√¨nh ƒë·ªông, s·∫Ω ƒë∆∞·ª£c t√≠nh to√°n l·∫°i khi resize
        const CONFIG = {
            bgSpeed: 20,
            bgFade: 0.1,
            particleEase: 0.05,
            gap: 0 // S·∫Ω t√≠nh theo DPR
        };

        const chars = 'HAPPY WEDDING';
        const charArray = chars.split('');

        // üü¢ H√ÄM KH·ªûI T·∫†O K√çCH TH∆Ø·ªöC CHU·∫®N RETINA
        function initSize() {
            DPR = window.devicePixelRatio || 1;
            
            // 1. Set k√≠ch th∆∞·ªõc hi·ªÉn th·ªã CSS (gi·ªØ nguy√™n logic m√†n h√¨nh)
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';

            // 2. Set k√≠ch th∆∞·ªõc th·ª±c c·ªßa Canvas (nh√¢n v·ªõi DPR ƒë·ªÉ si√™u n√©t)
            canvasWidth = Math.floor(window.innerWidth * DPR);
            canvasHeight = Math.floor(window.innerHeight * DPR);
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // 3. T√≠nh to√°n l·∫°i c√°c th√¥ng s·ªë d·ª±a tr√™n DPR
            // Font size m∆∞a matrix: 14px tr√™n m√†n th∆∞·ªùng -> 42px tr√™n m√†n 3x
            fontSize = 14 * DPR; 
            
            // Kho·∫£ng c√°ch gi·ªØa c√°c h·∫°t ch·ªØ (gap):
            // Mobile c·∫ßn gap nh·ªè h∆°n ƒë·ªÉ ch·ªØ m·ªãn, Desktop c·∫ßn gap l·ªõn h∆°n
            CONFIG.gap = Math.max(4 * DPR, 5); 

            // S·ªë c·ªôt m∆∞a
            const columns = Math.ceil(canvasWidth / fontSize);
            drops = [];
            for (let i = 0; i < columns; i++) drops[i] = 1;
        }

        class MatrixParticle {
            constructor(x, y) {
                this.targetX = x;
                this.targetY = y;
                // Random v·ªã tr√≠ xu·∫•t ph√°t ngo√†i m√†n h√¨nh
                this.x = Math.random() * canvasWidth;
                this.y = Math.random() * canvasHeight;
                this.char = charArray[Math.floor(Math.random() * charArray.length)];
                this.color = '#ff69b4';
            }

            update() {
                this.x += (this.targetX - this.x) * CONFIG.particleEase;
                this.y += (this.targetY - this.y) * CONFIG.particleEase;
                
                // Hi·ªáu ·ª©ng ƒë·ªïi k√Ω t·ª± ng·∫´u nhi√™n
                if (Math.random() > 0.98) {
                    this.char = charArray[Math.floor(Math.random() * charArray.length)];
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                // Font size cho h·∫°t c≈©ng ph·∫£i nh√¢n DPR
                // V·∫Ω nh·ªè h∆°n fontSize m∆∞a m·ªôt ch√∫t cho tinh t·∫ø
                ctx.font = (fontSize * 0.8) + "px monospace"; 
                ctx.fillText(this.char, this.x, this.y);
            }

            changeTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }
        }

        // üü¢ H√ÄM QU√âT ƒêI·ªÇM ·∫¢NH (ƒê√£ t·ªëi ∆∞u cho High DPI)
        function getTextCoordinates(text) {
            // T·∫°o canvas ph·ª• v·ªõi k√≠ch th∆∞·ªõc TH·∫¨T (l·ªõn)
            const bgCanvas = document.createElement('canvas');
            const bgCtx = bgCanvas.getContext('2d');
            bgCanvas.width = canvasWidth;
            bgCanvas.height = canvasHeight;

            // T√≠nh c·ª° ch·ªØ c∆° b·∫£n d·ª±a tr√™n chi·ªÅu r·ªông th·ª±c
            // Logic: Chi·ªÅu r·ªông * t·ª∑ l·ªá (0.15)
            let baseSize = Math.min(canvasWidth * 0.15, canvasHeight * 0.20);

            // T·ª± ƒë·ªông thu nh·ªè n·∫øu ch·ªØ qu√° d√†i
            if (text.length > 5 && text.length <= 10) baseSize *= 0.8;
            if (text.length > 10) baseSize *= 0.6;

            const lines = text.split('\n');
            const isSpecial = text.includes("TEAM BABIPRO");

            let sizes = lines.map((_, index) =>
                isSpecial ? (index === 0 ? baseSize : baseSize * 0.6) : baseSize
            );

            bgCtx.textAlign = "center";
            bgCtx.textBaseline = "middle";
            bgCtx.fillStyle = "#fff";

            // T√≠nh to√°n v·ªã tr√≠ Y ƒë·ªÉ cƒÉn gi·ªØa
            const spacing = baseSize * 0.3;
            const totalHeight = sizes.reduce((a, b) => a + b) + spacing * (sizes.length - 1);
            let currentY = canvasHeight / 2 - totalHeight / 2;

            lines.forEach((line, index) => {
                // Font ph·∫£i set theo pixel th·ª±c
                bgCtx.font = `bold ${sizes[index]}px Arial`;
                bgCtx.fillText(line, canvasWidth / 2, currentY + sizes[index] / 2);
                currentY += sizes[index] + spacing;
            });

            // L·∫•y d·ªØ li·ªáu pixel
            const data = bgCtx.getImageData(0, 0, canvasWidth, canvasHeight).data;
            const coords = [];

            // Qu√©t pixel (b∆∞·ªõc nh·∫£y gap c≈©ng ph·∫£i theo DPR)
            for (let y = 0; y < canvasHeight; y += CONFIG.gap) {
                for (let x = 0; x < canvasWidth; x += CONFIG.gap) {
                    // K√™nh Alpha > 128 (kh√¥ng ph·∫£i trong su·ªët)
                    if (data[(y * canvasWidth + x) * 4 + 3] > 128) {
                        coords.push({ x, y });
                    }
                }
            }
            return coords;
        }

        function initParticles(text) {
            const coords = getTextCoordinates(text);

            // Th√™m h·∫°t n·∫øu thi·∫øu
            if (particles.length < coords.length) {
                let need = coords.length - particles.length;
                while (need--) particles.push(new MatrixParticle(canvasWidth / 2, canvasHeight / 2));
            }

            // G√°n m·ª•c ti√™u cho h·∫°t
            particles.forEach((p, i) => {
                if (i < coords.length) {
                    p.changeTarget(coords[i].x, coords[i].y);
                    p.color = '#ff69b4';
                } else {
                    // H·∫°t th·ª´a bay ra ngo√†i m√†n h√¨nh
                    p.changeTarget(Math.random() * canvasWidth, Math.random() * canvasHeight);
                    p.color = 'rgba(0,0,0,0)'; // ·∫®n ƒëi
                }
            });
        }

        const timeline = [
            { text: "3", time: 6000 },
            { text: "2", time: 4000 },
            { text: "1", time: 4000 },
            { text: "HAPPY WEDDING", time: 9000 },
            { text: "ANH TH∆Ø\n‚ù§Ô∏è\n QUANG HUY", time: 9000 },
            { text: "04.01.2026", time: 9000 },
            { text: "TEAM BABIPRO\nCH√öC HAI ANH CH·ªä\nTRƒÇM NƒÇM H·∫†NH PH√öC", time: 10000 },
            { text: "M√ÉI IU H·∫∏ H·∫∏ H·∫∏", time: 9000 }
        ];
        let currentStep = 0;

        function runTimeline() {
            if (currentStep >= timeline.length) currentStep = 3;
            initParticles(timeline[currentStep].text);
            setTimeout(() => {
                currentStep++;
                runTimeline();
            }, timeline[currentStep].time);
        }

        let lastTime = 0;
        const interval = 1000 / CONFIG.bgSpeed;

        function draw(t) {
            requestAnimationFrame(draw);

            if (t - lastTime < interval) return;
            lastTime = t;

            // X√≥a n·ªÅn (t·∫°o v·ªát m·ªù)
            ctx.fillStyle = `rgba(0,0,0,${CONFIG.bgFade})`;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // V·∫º M∆ØA MATRIX
            ctx.font = fontSize + "px monospace";
            ctx.shadowBlur = 0; // T·∫Øt shadow ƒë·ªÉ n√©t h∆°n v√† m∆∞·ª£t h∆°n
            
            for(let i = 0; i < drops.length; i++) {
                // Ch·ªâ v·∫Ω m·ªôt s·ªë c·ªôt ng·∫´u nhi√™n ƒë·ªÉ gi·∫£m t·∫£i n·∫øu c·∫ßn, nh∆∞ng ·ªü ƒë√¢y v·∫Ω h·∫øt cho ƒë·∫πp
                const text = charArray[Math.floor(Math.random() * charArray.length)];
                const x = i * fontSize;
                const y = drops[i] * fontSize;

                if(Math.random() > 0.95) ctx.fillStyle = "#ffffff"; 
                else ctx.fillStyle = "rgba(255, 105, 180, 0.25)"; // H·ªìng nh·∫°t, trong su·ªët ƒë·ªÉ ƒë·ª° r·ªëi

                ctx.fillText(text, x, y);

                drops[i]++;
                // Reset khi ch·∫°m ƒë√°y
                if (y > canvasHeight && Math.random() > 0.975) drops[i] = 0;
            }

            // V·∫º CH·ªÆ H·∫†T
            // B·∫≠t shadow nh·∫π cho ch·ªØ ch√≠nh (nh√¢n DPR cho blur radius)
            ctx.shadowBlur = 5 * DPR;
            ctx.shadowColor = '#ff1493';
            
            particles.forEach(p => {
                p.update();
                if (p.color !== "rgba(0,0,0,0)") p.draw();
            });
            
            ctx.shadowBlur = 0; // Reset shadow
        }

        // Kh·ªüi t·∫°o ban ƒë·∫ßu
        initSize();

        // X·ª≠ l√Ω s·ª± ki·ªán Resize
        let resizeTimeout;
        window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                initSize();
                if (btn.style.display === "none") {
                    // Load l·∫°i ch·ªØ hi·ªán t·∫°i v·ªõi k√≠ch th∆∞·ªõc m·ªõi
                    let stepIndex = currentStep >= timeline.length ? 3 : (currentStep - 1 < 0 ? 0 : currentStep - 1);
                    initParticles(timeline[stepIndex].text);
                }
            }, 200);
        });

        // N√∫t Start
        btn.addEventListener('click', () => {
            audio.play().catch(() => {});
            audio.loop = true;
            btn.style.display = "none";
            
            // Ch·∫°y loop v·∫Ω
            draw(0);

            // B·∫Øt ƒë·∫ßu timeline
            setTimeout(() => {
                initParticles(timeline[0].text);
                runTimeline();
            }, 1000);
        });

    </script>
</body>

</html>
